import {URIValue, URIValueType} from 'rheactor-value-objects'
import {MaybeStringType, MaybeVersionNumberType} from './types'
import {maybe, refinement, Integer as IntegerType, irreducible, String as StringType, struct} from 'tcomb'

const $context = new URIValue('https://www.ietf.org/id/draft-ietf-appsawg-http-problem-01.txt')
const $contextVersion = 1

export class HttpProblem {
  /**
   * See https://datatracker.ietf.org/doc/draft-ietf-appsawg-http-problem/
   * @param {String} type     A URI reference [RFC3986] that identifies the problem type.
   *                          When dereferenced, it is encouraged to provide  human-readable documentation for the
   *                          problem type (e.g., using  HTML [W3C.REC-html401-19991224]). When this member is not
   *                          present, its value is assumed to be "about:blank".
   * @param {String} title    A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence
   *                          to occurrence of the problem, except for purposes of localisation.
   * @param {Number} status   The HTTP status code ([RFC7231], Section 6) generated by the origin server for this
   *                          occurrence of the problem.
   * @param {String} detail   An human readable explanation specific to this occurrence of the problem.
   * @constructor
   */
  constructor (type, title, status, detail) {
    this.name = HttpProblem.name
    this.type = URIValueType(type, ['HttpProblem', 'type:URIValue'])
    this.title = MaybeStringType(title, ['HttpProblem', 'title:?String'])
    this.status = HttpStatusCodeType(status, ['HttpProblem', 'status:HttpStatusCode'])
    this.detail = MaybeStringType(detail, ['HttpProblem', 'detail:?String'])
    this.$context = $context
    this.$contextVersion = $contextVersion
  }

  /**
   * @param {{$context: String, type: URIValue, type: String, status: Number, detail: (String|*)}} data
   * @returns {HttpProblem}
   */
  static fromJSON (data) {
    HttpProblemJSONType(data)
    return new HttpProblem(
      new URIValue(data.type),
      data.title,
      data.status,
      data.detail
    )
  }

  /**
   * @returns {URIValue}
   */
  static get $context () {
    return $context
  }

  /**
   * @returns {Number}
   */
  static get $contextVersion () {
    return $contextVersion
  }

  /**
   * Returns true if x is of type HttpProblem
   *
   * @param {object} x
   * @returns {boolean}
   */
  static is (x) {
    return x instanceof Error && x.name === HttpProblem.name && '$context' in x && URIValue.is(x.$context) && $context.equals(x.$context)
  }
}

HttpProblem.prototype = Object.create(Error.prototype)

/**
 * @returns {{$context: String, $contextVersion: Number, type: String, type: String, status: Number, detail: (String|*)}}
 */
HttpProblem.prototype.toJSON = function () {
  return {
    $context: this.$context.toString(),
    $contextVersion: $contextVersion,
    type: this.type.toString(),
    title: this.title,
    status: this.status,
    detail: this.detail
  }
}

export const HttpStatusCodeType = refinement(IntegerType, n => n >= 100 && n < 600, 'HttpStatusCodeType')
export const HttpProblemType = irreducible('HttpProblemType', HttpProblem.is)
export const MaybeHttpProblemType = maybe(HttpProblemType)
export const HttpProblemJSONType = struct({
  $context: refinement(StringType, s => s === HttpProblem.$context.toString(), 'HttpProblemContext'),
  $contextVersion: MaybeVersionNumberType,
  type: StringType,
  title: MaybeStringType,
  status: HttpStatusCodeType,
  detail: MaybeStringType
}, 'HttpProblemJSONType')
